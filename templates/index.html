<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>High Hazard</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <link rel="stylesheet" type="text/css" href="staic/main.css" />

    <link rel="icon" type="image/x-icon" src="./image2vector.svg">
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.css' rel='stylesheet' />
    <script src="https://unpkg.com/intersection-observer@0.12.0/intersection-observer.js"></script>
    <script src="https://unpkg.com/scrollama"></script>
    <link href="https://cdn.rawgit.com/michalsnik/aos/2.1.1/dist/aos.css" rel="stylesheet">
    <script src="https://cdn.rawgit.com/michalsnik/aos/2.1.1/dist/aos.js"></script>



    <style>

        body {
            margin:0;
            padding:0;
            overflow-x: hidden;
            background-color: #16212d;
            font-family: 'proxima-nova', sans-serif;
            font-size: 18px;
            text-align: left;
   
  

        }
       
        h3{
            font-family: 'orpheus-pro', serif;
            font-size: 24pt;
        }

        .my_container {
            max-width: 900px; /* keep */
            margin: auto; /* keep */
            padding:  25px 50px;
            line-height: 1.5em;
            font-size: 18px;
            color: white;
            z-index: 4;

        }



        
        a, a:hover, a:visited {
            color: #0071bc;
        }
        #map {
            top: 0;
            height: 100vh;
            width: 100vw;
            overflow-x: initial;
            position: sticky;
            margin-left: calc(-50vw + 50%);
            cursor:pointer;
           
        }
        #mapInset {
            bottom:50px;
            right:30px;
            height: 180px;
            width:250px;
            max-width:100%;
            position: fixed;
            z-index: -3;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            
        }
        #my_header {
            margin: auto;
            width: 100%;
            position: relative;
            z-index: 5;
            top: 0;
            height: 100vh;
            width: 100vw;

        }
        #my_header h1, #my_header h2, #my_header p {
            color: white;
              padding: 20%;
              width: 28em; /*There's very little padding so that the box hugs the paragraphs.  The lines of the box guide the eyes downward.*/
              padding-top: 0.12em;
              padding-bottom: 0.12em; /*Jagged right edges are unsightly, so I justify paragraphs.  Lines are short, so readability is unaffected.*/
              text-align: left; /*I try to imitate printed copy with the justified and indented paragraphs.*/
              margin-left: auto;
              margin-right: auto;
              margin-bottom: 0;
              margin-top: 0; /*Between the short lines and the large letters, I'm trying to entice readers to go on.  "Just another line.  It's not much."*/
              font-size: x-large;
        }
        #footer {
            width: 100%;
            min-height: 5vh;
            padding-top: 2vh;
            padding-bottom: 2vh;
            text-align: left;
            line-height: 1.5em;
            font-size: 13px;
            position: relative;
            z-index: 5;
        }
        #features {
            padding-top: 10vh;
            padding-bottom: 10vh;
        }
        .hidden {
            visibility: hidden;
        }
        .centered {
            width: 50vw;
            margin: 0 auto;
        }
        .lefty {
            width: 33vw;
            margin-left: 5vw;
        }
        .righty {
            width: 33vw;
            margin-left: 62vw;
        }
        .fully {
            width: 100%;
            margin: auto;
        }
        .light {
            color: #444;
            background-color: #16212d;
        }
        .dark {
            color: #fafafa;
            background-color: #16212d;
        }
        .step {
            padding-bottom: 50vh;
            /* margin-bottom: 10vh; */
            opacity: 0.15;

        }
        .step.active {
            opacity: 0.8;
        }

        .step div {
            padding:  25px 50px;
            line-height: 1.5em;
            font-size: 18px;
        }

        .step img {
            width: 100%;
        }

        @media (max-width: 750px) {
            .centered, .lefty, .righty, .fully {
                width: 90vw;
                margin: 0 auto;
            }
        }

        /* Fix issue on mobile browser where scroll breaks  */
        .mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan,
        .mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan .mapboxgl-canvas {
            touch-action: unset;
        }

        .bg-video-wrap {
            width: 100vw;
            height: 100vh;
            opacity: .5;
            margin-left: calc(-50vw + 50%);
            object-fit: cover;
            margin: 0px;
            overflow-x: initial;
            height: 110%;

          }
          video {
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            top: 0;
            left: 0;
            right: 0;
            margin-left: calc(-50vw + 50%);
            margin: 0px;
            overflow-x: initial;
             height: 110%;


       
          }
          .overlay {
            width: 100%;
            height: 100vh;
            width: 100wh;
            position: absolute;
            top: 0;
            opacity: 0;
            z-index: 4;
            opacity:1;
            overflow-x: initial;
            margin: 0px;


          }

          .fade {
            height: 100vh;
            margin: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #e7e7e7;
            transition: opacity .7s ease-in-out;

          }
          
          .fadeOut {
            opacity: 0;
            
          }
          
          .fadeIn {
            opacity: 1;
            background-color: #16212d;
        }
    
          a.button1{
            display:inline-block;
            padding:0.35em 1.2em;
            border:0.1em solid #FFFFFF;
            margin:0 0.3em 0.3em 0;
            border-radius:0.12em;
            box-sizing: border-box;
            text-decoration:none;
            font-family: 'proxima-nova', sans-serif;
            font-weight:300;
            color:#FFFFFF;
            text-align:center;
            transition: all 0.2s;
            }
          
            @media all and (max-width:30em){
            a.button1{
            display:block;
            margin:0.4em auto;
            }
            }

            a.button1:hover{
                color:#000000;
                background-color:#76a5ef;
                }

            #headline_title{
                line-height: 1.5em;
                text-align: center;
                margin: auto;
            }
            .viewport-header {
                position: relative;
                height: 100vh;
                text-align: center;
                display: flex;
                align-items: center;
                justify-content: center;
                font-family: 'orpheus-pro', serif;
                font-weight: bold;
                font-size: 34px;
                color: white;
                            }
                            p span {
                                display: block;
                              }
            
                              h2{
                                font-family: 'orpheus-pro', serif;
                                font-weight: medium;
                                font-size: 24pt;
                                color: white;
                             }
            
                .end_text{
                    margin: auto;
                    position: absolute;
                    padding:  200px 300px;
                    line-height: 1.5em;
                    font-size: 18px;
                    color: white;
                }

                @media only screen and (max-width: 400px) {
                    .end_text{
                        margin: auto;
                        position: absolute;
                        padding:  25px 50px;
                        line-height: 1.5em;
                        font-size: 18px;
                        color: white;
                        align-text: left;
                        align-items: left;
                    }
                  }

                  @media only screen and (min-width: 450px) {
                    .end_text{
                        margin: auto;
                        position: absolute;
                        padding:  25px 50px;                        
                        line-height: 1.5em;
                        font-size: 18px;
                        color: white;
                        align-text: left;
                        align-items: left;
                    }
                  }
        
        
        </style>
</head>


<body>
<div class="fadeIn fade fadeOut">
    <div class="bg-video-wrap" autoplay loop muted playsinline>
        <video  src="./water.mp4" autoplay="autoplay" loop="loop" muted defaultMuted playsinline  oncontextmenu="return false;"  preload="auto" >

            </video>
        </div>
    </div>
    <div id= "headline_title" class="overlay">
    <div class="viewport-header">
        <h1 > High Hazard</h1>

        </div>
        
    </div>


    <div class="my_container" > 
        <h2 id="footer" ><span>Reported and Written by Alan Halaly, Developed by Dana Cassidy</span></h2>

        <p> Half a century ago, the great environmental awakening that swept Florida and the nation helped stop the Cross-Florida Barge Canal.</p> 
        <p>But the project’s last remnant, Rodman Dam on the Ocklawaha River, still stands, entangled in political discourse as residents continue to use the area recreationally. The aging dam threatens more than ecosystems. </p> 
        <p> State officials acknowledge that, amid worsening storms and extreme rains associated with climate change, the dam is now at a high risk of breaching—endangering hundreds of rural homeowners who live nearby. </p> 
        <p>Officials haven't yet notified families of the risk, and activists worry about the dam causing potential loss of not only marine life but human life as well if the dam isn't fixed or taken down.</p>

    </div>


<div style="padding:5%"></div>

<div class="fadeIn fade fadeOut" id="map"></div>
<div id="mapInset"></div>
<div id="story"></div>

<div style="padding:5%"></div>

<div class="end_text">
            <div style="padding:5%"></div>

    <p>The Florida Department of Environmental Protection is working on an opt-in emergency notification system that would contact affected homeowners should the dam ever fail in a worst-case scenario.</p>

    <p>To further inform readers if they are at risk, WUFT built a searchable database of every address at risk in the FDEP’s 2021 Kirkpatrick Dam Inspection obtained by public records law.  Simply enter an address into the search bar, and it’ll return either a confirmation page with more information.</p>
    <div >

    </div>
    <div >

    </div>

    <div style="padding:5%"></div>
    <span><a style="align-items: center"href="{{ url_for('search') }}" class="button1" >Search for an address</a></span>
    <div style="padding:5%"></div>


    <p id="footer" ><span><i>To learn more about how we built this, visit out GitHub repository <a href= "https://github.com/danacassidy/wuft_project/tree/master">here</a>.</i></span></p>


</div>



    
   



<script>
 // INTERSECTION OBSERVER API

const observerOptions = {
  root: null, // Null = based on viewport
  rootMargin: "0px", // Margin for root if desired
  threshold: .95 // Percentage of visibility needed to execute function
};

function observerCallback(entries, observer) {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      // Fade in observed elements that are in view
      entry.target.classList.replace('fadeOut', 'fadeIn');
    }
    else {
      // Fade out observed elements that are not in view
      entry.target.classList.replace('fadeIn', 'fadeOut');
    }
  });
}

// Grab all relevant elements from DOM
const fadeElms = document.querySelectorAll('.fade');

// Call function for each element
const observer = new IntersectionObserver(observerCallback, observerOptions);
fadeElms.forEach(el => observer.observe(el));
</script>
<script src="./config.js"></script>

<script>
var initLoad = true;
var layerTypes = {
    'fill': ['fill-opacity'],
    'line': ['line-opacity'],
    'circle': ['circle-opacity', 'circle-stroke-opacity'],
    'symbol': ['icon-opacity', 'text-opacity'],
    'raster': ['raster-opacity'],
    'fill-extrusion': ['fill-extrusion-opacity'],
    'heatmap': ['heatmap-opacity']
}

var alignments = {
    'left': 'lefty',
    'center': 'centered',
    'right': 'righty',
    'full': 'fully'
}

function getLayerPaintType(layer) {
    var layerType = map.getLayer(layer).type;
    return layerTypes[layerType];
}

function setLayerOpacity(layer) {
    var paintProps = getLayerPaintType(layer.layer);
    paintProps.forEach(function(prop) {
        var options = {};
        if (layer.duration) {
            var transitionProp = prop + "-transition";
            options = { "duration": layer.duration };
            map.setPaintProperty(layer.layer, transitionProp, options);
        }
        map.setPaintProperty(layer.layer, prop, layer.opacity, options);
    });
}

var story = document.getElementById('story');
var features = document.createElement('div');
features.setAttribute('id', 'features');

var header = document.createElement('div');

if (config.title) {
    var titleText = document.createElement('h1');
    titleText.innerText = config.title;
    header.appendChild(titleText);
}

if (config.subtitle) {
    var subtitleText = document.createElement('h2');
    subtitleText.innerText = config.subtitle;
    header.appendChild(subtitleText);
}

if (config.byline) {
    var bylineText = document.createElement('p');
    bylineText.innerText = config.byline;
    header.appendChild(bylineText);
}

if (header.innerText.length > 0) {
    header.classList.add(config.theme);
    header.setAttribute('id', 'header');
    story.appendChild(header);
}

config.chapters.forEach((record, idx) => {
    var container = document.createElement('div');
    var chapter = document.createElement('div');

    if (record.title) {
        var title = document.createElement('h3');
        title.innerText = record.title;
        chapter.appendChild(title);
    }

    if (record.image) {
        var image = new Image();
        image.src = record.image;
        chapter.appendChild(image);
    }

    if (record.description) {
        var story = document.createElement('p');
        story.innerHTML = record.description;
        chapter.appendChild(story);
    }

    container.setAttribute('id', record.id);
    container.classList.add('step');
    if (idx === 0) {
        container.classList.add('active');
    }

    chapter.classList.add(config.theme);
    container.appendChild(chapter);
    container.classList.add(alignments[record.alignment] || 'centered');
    if (record.hidden) {
        container.classList.add('hidden');
    }
    features.appendChild(container);
});

story.appendChild(features);

var footer = document.createElement('div');

if (config.footer) {
    var footerText = document.createElement('p');
    footerText.innerHTML = config.footer;
    footer.appendChild(footerText);
}

if (footer.innerText.length > 0) {
    footer.classList.add(config.theme);
    footer.setAttribute('id', 'footer');
    story.appendChild(footer);
}

mapboxgl.accessToken = config.accessToken;

const transformRequest = (url) => {
    const hasQuery = url.indexOf("?") !== -1;
    const suffix = hasQuery ? "&pluginName=scrollytellingV2" : "?pluginName=scrollytellingV2";
    return {
      url: url + suffix
    }
}

var map = new mapboxgl.Map({
    container: 'map',
    style: config.style,
    center: config.chapters[0].location.center,
    zoom: config.chapters[0].location.zoom,
    bearing: config.chapters[0].location.bearing,
    pitch: config.chapters[0].location.pitch,
    interactive: false,
    transformRequest: transformRequest,
    projection: config.projection
});

// Create a inset map if enabled in config.js
if (config.inset) {
 var insetMap = new mapboxgl.Map({
    container: 'mapInset', // container id
    style: 'mapbox://styles/mapbox/dark-v10', //hosted style id
    center: config.chapters[0].location.center,
    // Hardcode above center value if you want insetMap to be static.
    zoom: 3, // starting zoom
    hash: false,
    interactive: false,
    attributionControl: false,
    //Future: Once official mapbox-gl-js has globe view enabled,
    //insetmap can be a globe with the following parameter.
    //projection: 'globe'
  });
}

if (config.showMarkers) {
    var marker = new mapboxgl.Marker({ color: config.markerColor });
    marker.setLngLat(config.chapters[0].location.center).addTo(map);
}

// instantiate the scrollama
var scroller = scrollama();


map.on("load", function() {
    if (config.use3dTerrain) {
        map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
        });
        // add the DEM source as a terrain layer with exaggerated height
        map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });

        // add a sky layer that will show when the map is highly pitched
        map.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
                'sky-type': 'atmosphere',
                'sky-atmosphere-sun': [0.0, 0.0],
                'sky-atmosphere-sun-intensity': 15
            }
        });
    };

    // As the map moves, grab and update bounds in inset map.
    if (config.inset) {
    map.on('move', getInsetBounds);
    }
    // setup the instance, pass callback functions
    scroller
    .setup({
        step: '.step',
        offset: 0.5,
        progress: true
    })
    .onStepEnter(async response => {
        var chapter = config.chapters.find(chap => chap.id === response.element.id);
        response.element.classList.add('active');
        map[chapter.mapAnimation || 'flyTo'](chapter.location);
        // Incase you do not want to have a dynamic inset map,
        // rather want to keep it a static view but still change the
        // bbox as main map move: comment out the below if section.
        if (config.inset) {
          if (chapter.location.zoom < 5) {
            insetMap.flyTo({center: chapter.location.center, zoom: 0});
          }
          else {
            insetMap.flyTo({center: chapter.location.center, zoom: 3});
          }
        }
        if (config.showMarkers) {
            marker.setLngLat(chapter.location.center);
        }
        if (chapter.onChapterEnter.length > 0) {
            chapter.onChapterEnter.forEach(setLayerOpacity);
        }
        if (chapter.callback) {
            window[chapter.callback]();
        }
        if (chapter.rotateAnimation) {
            map.once('moveend', () => {
                const rotateNumber = map.getBearing();
                map.rotateTo(rotateNumber + 180, {
                    duration: 30000, easing: function (t) {
                        return t;
                    }
                });
            });
        }
    })
    .onStepExit(response => {
        var chapter = config.chapters.find(chap => chap.id === response.element.id);
        response.element.classList.remove('active');
        if (chapter.onChapterExit.length > 0) {
            chapter.onChapterExit.forEach(setLayerOpacity);
        }
    });
});

//Helper functions for insetmap
function getInsetBounds() {
            let bounds = map.getBounds();

            let boundsJson = {
                "type": "FeatureCollection",
                "features": [{
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [
                            [
                                [
                                    bounds._sw.lng,
                                    bounds._sw.lat
                                ],
                                [
                                    bounds._ne.lng,
                                    bounds._sw.lat
                                ],
                                [
                                    bounds._ne.lng,
                                    bounds._ne.lat
                                ],
                                [
                                    bounds._sw.lng,
                                    bounds._ne.lat
                                ],
                                [
                                    bounds._sw.lng,
                                    bounds._sw.lat
                                ]
                            ]
                        ]
                    }
                }]
            }

            if (initLoad) {
                addInsetLayer(boundsJson);
                initLoad = false;
            } else {
                updateInsetLayer(boundsJson);
            }

        }

function addInsetLayer(bounds) {
    insetMap.addSource('boundsSource', {
        'type': 'geojson',
        'data': bounds
    });

    insetMap.addLayer({
        'id': 'boundsLayer',
        'type': 'fill',
        'source': 'boundsSource', // reference the data source
        'layout': {},
        'paint': {
            'fill-color': '#fff', // blue color fill
            'fill-opacity': 0.2
        }
    });
    // // Add a black outline around the polygon.
    insetMap.addLayer({
        'id': 'outlineLayer',
        'type': 'line',
        'source': 'boundsSource',
        'layout': {},
        'paint': {
            'line-color': '#000',
            'line-width': 1
        }
    });
}

function updateInsetLayer(bounds) {
    insetMap.getSource('boundsSource').setData(bounds);
}



// setup resize event
window.addEventListener('resize', scroller.resize);

</script>

</body>
</html>
